!function(f){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).nurbs=f()}}(function(){return function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){return o(e[i][1][r]||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}({1:[function(require,module,exports){var nurbs=require("nurbs");module.exports=nurbs},{nurbs:2}],2:[function(require,module,exports){"use strict";var inferType=require("./src/utils/infer-type"),computeCacheKey=require("./src/utils/cache-key"),isNdarray=require("./src/utils/is-ndarray"),isNdarrayLike=require("./src/utils/is-ndarray-like"),createAccessors=require("./src/utils/create-accessors"),numericalDerivative=require("./src/numerical-derivative"),isArrayLike=require("./src/utils/is-array-like"),createEvaluator=require("./src/evaluate"),createTransform=require("./src/transform"),createSupport=require("./src/support"),BOUNDARY_TYPES={open:"open",closed:"closed",clamped:"clamped"};function isBlank(x){return null==x}function domainGetter(){var sizeArray,ret=[],ptr=this.points;ptr?isNdarrayLike(ptr)&&(sizeArray=ptr.shape):sizeArray=this.size;for(var d=0;d<this.splineDimension;d++){var size=sizeArray?sizeArray[d]:ptr.length,p=this.degree[d],isClosed="closed"===this.boundary[d];if(this.knots&&this.knots[d]){var k=this.knots[d];ret[d]=[k[isClosed?0:p],k[size]]}else ret[d]=[isClosed?0:p,size];ptr&&(ptr=ptr[0])}return ret}module.exports=function(points,degree,knots,weights,boundary,opts){var ctor=function(points,degree,knots,weights,boundary,opts){return parseFcn(points,degree,knots,weights,boundary,opts),ctor},parseFcn=function(points,degree,knots,weights,boundary,opts){var i,dflt;!points||isArrayLike(points)||isNdarray(points)?(opts=opts||{},this.weights=weights,this.knots=knots,this.degree=degree,this.points=points,this.boundary=boundary,this.debug=opts.debug,this.checkBounds=!!opts.checkBounds):(opts=points,this.debug=points.debug,this.checkBounds=!!points.checkBounds,this.weights=points.weights,this.knots=points.knots,this.degree=points.degree,this.boundary=points.boundary,this.points=points.points),Object.defineProperty(this,"size",{value:opts.size,writable:!0,configurable:!0});var pointType=inferType(this.points),weightType=inferType(this.weights),knotType=inferType(this.knots);if(this.points)switch(pointType){case inferType.GENERIC_NDARRAY:case inferType.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case inferType.ARRAY_OF_ARRAYS:var splineDimension=0,size=this.size||[];size.length=0;for(var ptr=this.points;isArrayLike(ptr[0]);ptr=ptr[0])splineDimension++,size.push(ptr.length);if(0===splineDimension)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:splineDimension,writable:!1,configurable:!0},dimension:{value:ptr.length,writable:!1,configurable:!0},size:{get:function(){for(var size=[],i=size.length=0,ptr=this.points;i<this.splineDimension;i++,ptr=ptr[0])size[i]=ptr.length;return size},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case inferType.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(void 0===this.size||null===this.size)throw new Error("Either points or a control hull size must be provided.");if(isArrayLike(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),0===this.size.length)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(isArrayLike(this.degree)){for(i=0;i<this.splineDimension;i++)if(isBlank(this.degree[i]))throw new Error("Missing degree in dimension "+(i+1))}else{var hasBaseDegree=!isBlank(this.degree),baseDegree=isBlank(this.degree)?2:this.degree;for(this.degree=[],i=0;i<this.splineDimension;i++)if(this.size[i]<=baseDegree){if(hasBaseDegree)throw new Error("Expected at least "+(baseDegree+1)+" points for degree "+baseDegree+" spline in dimension "+(i+1)+" but got only "+this.size[i]);this.degree[i]=this.size[i]-1}else this.degree[i]=baseDegree}if(dflt="string"!=typeof this.boundary?"open":this.boundary,!BOUNDARY_TYPES[dflt])throw new Error("Boundary type must be one of "+Object.keys(BOUNDARY_TYPES)+". Got "+dflt);for(this.boundary=isArrayLike(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension,i=0;i<this.splineDimension;i++)if(this.boundary[i]=isBlank(this.boundary[i])?dflt:this.boundary[i],!BOUNDARY_TYPES[dflt])throw new Error("Boundary type must be one of "+Object.keys(BOUNDARY_TYPES)+". Got "+dflt+" for dimension "+(i+1));switch(knotType){case inferType.ARRAY_OF_ARRAYS:for(isArrayLike(this.knots)&&0<this.knots.length&&!isArrayLike(this.knots[0])&&(this.knots=[this.knots]),i=0;i<this.splineDimension;i++){if(this.size[i]<=this.degree[i])throw new Error("Expected at least "+(this.degree[i]+1)+" points in dimension "+(i+1)+" but got "+this.size[i]+".");if(isArrayLike(this.knots[i])){if("closed"!==this.boundary[i]&&this.knots[i].length!==this.degree[i]+this.size[i]+1)throw new Error("Expected "+(this.degree[i]+this.size[i]+1)+" knots in dimension "+(i+1)+" but got "+this.knots[i].length+".");if("closed"===this.boundary[i]&&this.knots[i].length!==this.size[i]+1&&this.knots[i].length!==this.size[i]+this.degree[i]+1)throw new Error("Expected "+(this.size[i]+1)+" knots for closed spline in dimension "+(i+1)+" but got "+this.knots[i].length+".")}}break;case inferType.NDARRAY:}var newCacheKey=computeCacheKey(this,this.debug,this.checkBounds,pointType,weightType,knotType);if(newCacheKey!==this.__cacheKey){this.__cacheKey=newCacheKey;var accessors=createAccessors(this);this.evaluate=createEvaluator(this.__cacheKey,this,accessors,this.debug,this.checkBounds,!1),this.transform=createTransform(this.__cacheKey,this,accessors,this.debug),this.support=createSupport(this.__cacheKey,this,accessors,this.debug,this.checkBounds),this.evaluator=function(derivativeOrder,isBasis){return createEvaluator(this.__cacheKey,this,accessors,this.debug,this.checkBounds,isBasis,derivativeOrder)}}return this.numericalDerivative=numericalDerivative.bind(this),this}.bind(ctor);return Object.defineProperty(ctor,"domain",{get:domainGetter}),parseFcn(points,degree,knots,weights,boundary,opts),ctor}},{"./src/evaluate":3,"./src/numerical-derivative":4,"./src/support":5,"./src/transform":6,"./src/utils/cache-key":8,"./src/utils/create-accessors":9,"./src/utils/infer-type":10,"./src/utils/is-array-like":11,"./src/utils/is-ndarray":13,"./src/utils/is-ndarray-like":12}],3:[function(require,module,exports){"use strict";var ndloop=require("./utils/ndloop"),variable=require("./utils/variable"),accessorPreamble=require("./utils/accessor-preamble"),inferType=require("./utils/infer-type"),isArrayLike=require("./utils/is-array-like"),sizeGetter=require("./utils/size-getter"),evaluatorCache={},codeCache={};module.exports=function(cacheKey,nurbs,accessors,debug,checkBounds,isBasis,derivative){var i,j,n,m,d,kvar,splineDimension=nurbs.splineDimension,points=nurbs.points,degree=nurbs.degree,weights=nurbs.weights,hasWeights=void 0!==weights,knots=nurbs.knots,spaceDimension=nurbs.dimension,boundary=nurbs.boundary;if(null!=derivative){Array.isArray(derivative)||(derivative=[derivative]);var totalDerivativeOrder=0;for(i=0;i<splineDimension;i++)void 0===derivative[i]&&(derivative[i]=0),totalDerivativeOrder+=derivative[i];if(hasWeights&&1<totalDerivativeOrder)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+totalDerivativeOrder+".")}isBasis&&(cacheKey="Basis"+cacheKey),derivative&&(cacheKey="Der"+derivative.join("_")+"_"+cacheKey);var cachedEvaluator=evaluatorCache[cacheKey];if(debug)var logger="function"==typeof debug?debug:console.log;if(cachedEvaluator)return debug&&logger(codeCache[cacheKey]),cachedEvaluator.bind(nurbs);var code=[],functionName="evaluate"+cacheKey,pointAccessor=accessors.point;isBasis&&(pointAccessor=function(src,period){for(var terms=[],i=0;i<src.length;i++){for(var accessor=src[i],terms2=[],j=0;j<accessor.length;j++)0!==accessor[j]&&terms2.push(accessor[j]);accessor=terms2.join(" + "),period[i]&&(accessor="("+accessor+" + "+period[i]+") % "+period[i]),terms.push(accessor+" === "+indexVar(i))}return"(("+terms.join(" && ")+") ? 1 : 0)"});var weightAccessor=accessors.weight,knotAccessor=accessors.knot,knotVar=variable("k"),pointVar=variable("x"),weightVar=variable("w"),indexVar=variable("i"),tVar=variable("t"),domainVar=debug?"domain":"d",sizeVar=variable(debug?"size":"s"),knotIndex=variable(debug?"knotIndex":"j"),allDimensionUniform=!0;for(d=0;d<splineDimension;d++)isArrayLike(knots)&&isArrayLike(knots[d])&&(allDimensionUniform=!1);function line(str){code.push("  "+(str||""))}function debugLine(str){debug&&line(str)}if(isBasis)var indexArgs=[];var parameterArgs=[];for(i=0;i<splineDimension;i++)isBasis&&indexArgs.push(indexVar([i])),parameterArgs.push(tVar([i]));for(code.push("function "+functionName+" ("+(isBasis?"":"out, ")+parameterArgs.join(", ")+(isBasis?", "+indexArgs.join(", "):"")+") {"),line("var h, m, a, b;"),checkBounds&&(line("var "+domainVar+" = this.domain;"),line("for (var i = 0; i < this.splineDimension; i++) {"),line("  a = arguments[i + 1];"),line("  if (a < "+domainVar+"[i][0] || a > "+domainVar+"[i][1] || a === undefined || isNaN(a)) {"),line("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+"+domainVar+"[i][0]+', '+"+domainVar+"[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');"),line("  }"),line("}")),d=0;d<splineDimension;d++)line("var "+sizeVar(d)+" = "+sizeGetter(points,"this.points",d)+";");function ternary(cond,a,b){return"("+cond+") ? ("+a+") : ("+b+")"}code.push(accessorPreamble(nurbs,"x","this.points",points)),hasWeights&&code.push(accessorPreamble(nurbs,"w","this.weights",weights)),allDimensionUniform||code.push(accessorPreamble(nurbs,"k","this.knots",knots));var hasKnots=[];for(d=0;d<splineDimension;d++)switch(inferType(knots)){case inferType.NDARRAY:hasKnots[d]=!0;break;case inferType.ARRAY_OF_ARRAYS:hasKnots[d]=isArrayLike(knots[d])}for(d=0;d<splineDimension;d++)if(hasKnots[d])for(debugLine("\n  // Bisect to locate the knot interval in dimension "+d+"\n"),line("var "+knotIndex(d)+" = 0;"),line("h = "+sizeVar(d)+";"),line("while(h > "+knotIndex(d)+" + 1) {"),line("  m = 0.5 * (h + "+knotIndex(d)+") | 0;"),line("  if ("+knotAccessor([d,"m"])+" > "+tVar(d)+") h = m;"),line("  else "+knotIndex(d)+" = m;"),line("}"),debugLine("\n  // Fetch knots for dimension "+d+"\n"),i=1-degree[d];i<=degree[d];i++)"closed"===boundary[d]?line(i<0?"var "+knotVar([d,i+degree[d]-1])+" = "+ternary(knotIndex(d)+" < "+-i,knotAccessor([d,0])+" + "+knotAccessor([d,[sizeVar(d),knotIndex(d),i]])+" - "+knotAccessor([d,[sizeVar(d)]]),knotAccessor([d,[knotIndex(d),i]]))+";":0<i?"var "+knotVar([d,i+degree[d]-1])+" = "+ternary(knotIndex(d)+" + "+i+" > "+sizeVar(d),knotAccessor([d,sizeVar(d)])+" + "+knotAccessor([d,i+" + "+knotIndex(d)+" - "+sizeVar(d)])+" - "+knotAccessor([d,0]),knotAccessor([d,[knotIndex(d),i]]))+";":"var "+knotVar([d,i+degree[d]-1])+" = "+knotAccessor([d,[knotIndex(d),i]])+";"):line("var "+knotVar([d,i+degree[d]-1])+" = "+knotAccessor([d,[knotIndex(d),i]])+";");else{for(debugLine("\n  // Directly compute knot interval for dimension "+d+"\n"),"closed"===boundary[d]?line(knotIndex(d)+" = ("+tVar(d)+" | 0) % "+sizeVar(d)+";"):(line(knotIndex(d)+" = ("+tVar(d)+" | 0);"),line("if ("+knotIndex(d)+" < "+degree[d]+") "+knotIndex(d)+" = "+degree[d]+";"),line("if ("+knotIndex(d)+" > "+sizeVar(d)+" - 1) "+knotIndex(d)+" = "+sizeVar(d)+" - 1;")),debugLine("\n  // Compute and clamp knots for dimension "+d+"\n"),i=1-degree[d];i<=degree[d];i++)line("var "+(kvar=knotVar([d,i+degree[d]-1]))+" = "+knotIndex(d)+" + "+i+";");if("clamped"===boundary[d])for(i=1-degree[d];i<=degree[d];i++)kvar=knotVar([d,i+degree[d]-1]),i<0&&line("if ("+kvar+" < "+degree[d]+") "+kvar+" = "+degree[d]+";"),0<i&&line("if ("+kvar+" > "+sizeVar(d)+") "+kvar+" = "+sizeVar(d)+";");"closed"===boundary[d]&&(debugLine("\n  // Wrap the B-Spline parameter for closed boundary"),line(tVar(d)+" %= "+sizeVar(d)+";"))}for(d=0,n=[];d<splineDimension;d++)n[d]=degree[d]+1;for(hasWeights&&(debugLine("\n  // Fetch weights\n"),ndloop(n,function(dst){for(var readIdx=[],period=[],d=0;d<splineDimension;d++)readIdx[d]=[knotIndex(d),dst[d]-degree[d]],"closed"===boundary[d]&&dst[d]-degree[d]<0&&(period[d]=sizeVar(d));line("var "+weightVar(dst)+" = "+weightAccessor(readIdx,period)+";")})),debug&&line(hasWeights?"\n  // Fetch points and project into homogeneous (weighted) coordinates\n":"\n  // Fetch points\n"),ndloop(n,function(dst){for(var readIdx=[],period=[],d=0;d<splineDimension;d++)readIdx[d]=[knotIndex(d),dst[d]-degree[d]],"closed"===boundary[d]&&dst[d]-degree[d]<0&&(period[d]=sizeVar(d));if(isBasis)line(hasWeights?"var "+pointVar(dst)+" = "+pointAccessor(readIdx,period)+" * "+weightVar(dst)+";":"var "+pointVar(dst)+" = "+pointAccessor(readIdx,period)+";");else for(d=0;d<spaceDimension;d++){var dstWithDim=dst.concat(d);readIdx[splineDimension]=d,line(hasWeights?"var "+pointVar(dstWithDim)+" = "+pointAccessor(readIdx,period)+" * "+weightVar(dst)+";":"var "+pointVar(dstWithDim)+" = "+pointAccessor(readIdx,period)+";")}}),debugLine("\n"),debugLine("// Perform De Boor's algorithm"),d=n.length-1;0<=d;d--)for(n[d]=[degree[d],degree[d]+1],i=0;i<degree[d];i++)for(debugLine("\n  // Degree "+degree[d]+" evaluation in dimension "+d+", step "+(i+1)+"\n"),j=degree[d];i<j;j--){var isDerivative=derivative&&degree[d]-i-derivative[d]<=0;isDerivative?(line("m = 1 / ("+knotVar([d,j-i+degree[d]-1])+" - "+knotVar([d,j-1])+");"),hasWeights&&(line("a = ("+tVar(d)+" - "+knotVar([d,j-1])+") * m;"),line("b = 1 - a;"))):(line("a = ("+tVar(d)+" - "+knotVar([d,j-1])+") / ("+knotVar([d,j-i+degree[d]-1])+" - "+knotVar([d,j-1])+");"),line("b = 1 - a;")),hasWeights&&ndloop(n,function(ii){var ij=ii.slice(),ij1=ii.slice();ij[d]=j,ij1[d]=j-1,isDerivative&&hasWeights&&line("h = "+weightVar(ij)+";"),line(weightVar(ij)+" = b * "+weightVar(ij1)+" + a * "+weightVar(ij)+";")}),ndloop(n,function(ii){var weightFactor,pt1,pt2,ij=ii.slice(),ij1=ii.slice();if(ij[d]=j,ij1[d]=j-1,isDerivative){var derivCoeff=i+1;if(isBasis)weightFactor=hasWeights?"h * "+weightVar(ij1)+" / "+weightVar(ij)+" * ":"",pt1=pointVar(ij)+(hasWeights?" / h":""),pt2=pointVar(ij1)+(hasWeights?" / "+weightVar(ij1):""),line(pointVar(ij)+" = "+derivCoeff+" * "+weightFactor+"("+pt1+" - "+pt2+") * m;");else{var ijWithDimension=ij.slice(),ij1WithDimension=ij1.slice();for(m=0;m<spaceDimension;m++)ijWithDimension[splineDimension]=ij1WithDimension[splineDimension]=m,weightFactor=hasWeights?"h * "+weightVar(ij1)+" / "+weightVar(ij)+" * ":"",pt1=pointVar(ijWithDimension)+(hasWeights?" / h":""),pt2=pointVar(ij1WithDimension)+(hasWeights?" / "+weightVar(ij1):""),line(pointVar(ijWithDimension)+" = "+derivCoeff+" * "+weightFactor+"("+pt1+" - "+pt2+") * m;")}}else if(isBasis)line(pointVar(ij)+" = b * "+pointVar(ij1)+" + a * "+pointVar(ij)+";");else for(m=0;m<spaceDimension;m++)ij[splineDimension]=ij1[splineDimension]=m,line(pointVar(ij)+" = b * "+pointVar(ij1)+" + a * "+pointVar(ij)+";")}),debugLine("\n")}if(debug&&line(hasWeights?"\n  // Project back from homogeneous coordinates and return final output\n":"\n  // Return final output\n"),isBasis)line(hasWeights?"return "+pointVar(degree)+" / "+weightVar(degree)+";":"return "+pointVar(degree)+";");else for(d=0;d<spaceDimension;d++)line(hasWeights?"out["+d+"] = "+pointVar(degree.concat([d]))+" / "+weightVar(degree)+";":"out["+d+"] = "+pointVar(degree.concat([d]))+";");if(isBasis||line("return out;"),code.push("}"),debug){var codeStr=code.join("\n");logger(codeStr),codeCache[cacheKey]=codeStr}var evaluator=new Function([code.join("\n"),"; return ",functionName].join(""))();return(evaluatorCache[cacheKey]=evaluator).bind(nurbs)}},{"./utils/accessor-preamble":7,"./utils/infer-type":10,"./utils/is-array-like":11,"./utils/ndloop":14,"./utils/size-getter":15,"./utils/variable":16}],4:[function(require,module,exports){"use strict";var args=[],tmp=[];module.exports=function(out,order,dimension){if(1!==order)throw new Error("Numerical derivative not implemented for order n = "+order+".");var i,h=void 0===arguments[this.splineDimension+3]?1e-4:arguments[this.splineDimension+3];for(args.length=this.splineDimension,i=0;i<this.splineDimension;i++)args[i+1]=arguments[i+3];var tm,tp,T,domain=this.domain,k0=domain[dimension][0],k1=domain[dimension][1],t0=args[dimension+1],dt=(k1-k0)*h;for("closed"===this.boundary[dimension]?(tm=k0+(t0-k0-dt+(T=k1-k0))%T,tp=k0+(t0-k0+dt+T)%T,dt*=2):(tm=Math.min(k1,Math.max(k0,t0-dt)),dt=(tp=Math.min(k1,Math.max(k0,t0+dt)))-tm),args[dimension+1]=tm,args[0]=tmp,this.evaluate.apply(null,args),args[dimension+1]=tp,args[0]=out,this.evaluate.apply(null,args),i=0;i<this.dimension;i++)out[i]=(out[i]-tmp[i])/dt;return out}},{}],5:[function(require,module,exports){"use strict";var ndloop=require("./utils/ndloop"),variable=require("./utils/variable"),accessorPreamble=require("./utils/accessor-preamble"),inferType=require("./utils/infer-type"),isArrayLike=require("./utils/is-array-like"),sizeGetter=require("./utils/size-getter"),supportCache={};module.exports=function(cacheKey,nurbs,accessors,debug,checkBounds){var cachedSupport=supportCache[cacheKey];if(cachedSupport)return cachedSupport.bind(nurbs);var i,n,d,degree=nurbs.degree,knots=nurbs.knots,splineDimension=nurbs.splineDimension,boundary=nurbs.boundary,code=[],functionName="support"+cacheKey,knotAccessor=accessors.knot,tVar=variable("t"),domainVar=debug?"domain":"d",sizeVar=variable(debug?"size":"s"),knotIndex=variable(debug?"knotIndex":"i"),allDimensionUniform=!0;for(d=0;d<splineDimension;d++)isArrayLike(knots)&&isArrayLike(knots[d])&&(allDimensionUniform=!1);function line(str){code.push("  "+(str||""))}var parameterArgs=[];for(i=0;i<splineDimension;i++)parameterArgs.push(tVar([i]));code.push("function "+functionName+" (out, "+parameterArgs.join(", ")+") {");var c=0;function pushSupport(args,period){line(void 0===period?"out["+c+++"] = "+args.join(" + ")+";":"out["+c+++"] = ("+args.join(" + ")+" + "+period+") % "+period+";")}for(line("var h, m;"),line("var c = 0;"),checkBounds&&(line("var "+domainVar+" = this.domain;"),line("for (var i = 0; i < this.splineDimension; i++) {"),line("  a = arguments[i + 1];"),line("  if (a < "+domainVar+"[i][0] || a > "+domainVar+"[i][1] || a === undefined || isNaN(a)) {"),line("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+"+domainVar+"[i][0]+', '+"+domainVar+"[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');"),line("  }"),line("}")),d=0;d<splineDimension;d++)line("var "+sizeVar(d)+" = "+sizeGetter(nurbs.points,"this.points",d)+";");allDimensionUniform||code.push(accessorPreamble(nurbs,"k","this.knots",knots));var hasKnots=[];for(d=0;d<splineDimension;d++)switch(inferType(knots)){case inferType.NDARRAY:hasKnots[d]=!0;break;case inferType.ARRAY_OF_ARRAYS:hasKnots[d]=isArrayLike(knots[d])}for(d=0;d<splineDimension;d++)hasKnots[d]?(line("var "+knotIndex(d)+" = 0;"),line("h = "+sizeVar(d)+";"),line("while(h > "+knotIndex(d)+" + 1) {"),line("  m = 0.5 * (h + "+knotIndex(d)+") | 0;"),line("  if ("+knotAccessor([d,"m"])+" > "+tVar(d)+") h = m;"),line("  else "+knotIndex(d)+" = m;"),line("}")):"closed"===boundary[d]?line(knotIndex(d)+" = ("+tVar(d)+" | 0) % "+sizeVar(d)+";"):(line(knotIndex(d)+" = ("+tVar(d)+" | 0);"),line("if ("+knotIndex(d)+" < "+degree[d]+") "+knotIndex(d)+" = "+degree[d]+";"),line("if ("+knotIndex(d)+" > "+sizeVar(d)+" - 1) "+knotIndex(d)+" = "+sizeVar(d)+" - 1;"));for(d=0,n=[];d<splineDimension;d++)n[d]=degree[d]+1;ndloop(n,function(dst){for(var readIdx=[],period=[],d=0;d<splineDimension;d++)readIdx[d]=[knotIndex(d),dst[d]-degree[d]],"closed"===boundary[d]&&dst[d]-degree[d]<0&&(period[d]=sizeVar(d));for(d=0;d<splineDimension;d++)pushSupport(readIdx[d],period[d])}),line("out.length = "+c+";"),line("return out;"),code.push("}"),debug&&console.log(code.join("\n"));var evaluator=new Function([code.join("\n"),"; return ",functionName].join(""))();return(supportCache[cacheKey]=evaluator).bind(nurbs)}},{"./utils/accessor-preamble":7,"./utils/infer-type":10,"./utils/is-array-like":11,"./utils/ndloop":14,"./utils/size-getter":15,"./utils/variable":16}],6:[function(require,module,exports){"use strict";var transformerCache={},accessorPreamble=require("./utils/accessor-preamble"),sizeGetter=require("./utils/size-getter"),variable=require("./utils/variable");module.exports=function(cacheKey,nurbs,accessors,debug){var i,j,iterator,iterators,terms,n,rvalue,lvalue,cachedTransformer=transformerCache[cacheKey];if(cachedTransformer)return cachedTransformer.bind(nurbs);var code=[],functionName="transform"+cacheKey;code.push("function "+functionName+"(m) {"),code.push("var i, w;"),code.push(accessorPreamble(nurbs,"x","this.points",nurbs.points));var sizeVar=variable(debug?"size":"s");for(i=0;i<nurbs.splineDimension;i++)code.push("var "+sizeVar(i)+" = "+sizeGetter(nurbs.points,"this.points",i)+";");for(iterators=[],i=0;i<nurbs.splineDimension;i++)iterator="i"+i,iterators.push(iterator),code.push("for ("+iterator+" = "+sizeVar(i)+"- 1; "+iterator+" >= 0; "+iterator+"--) {");for(i=0;i<nurbs.dimension;i++)code.push("x"+i+" = "+accessors.point(iterators.concat([i])));for(terms=[],i=0;i<nurbs.dimension;i++)terms.push("m["+((nurbs.dimension+1)*(i+1)-1)+"] * x"+i);for(terms.push("m["+((nurbs.dimension+1)*(nurbs.dimension+1)-1)+"]"),code.push("var w = ("+terms.join(" + ")+") || 1.0;"),i=0;i<nurbs.dimension;i++){for(terms=[],n=nurbs.dimension,j=0;j<n;j++)terms.push("m["+(j*(n+1)+i)+"] * x"+j);terms.push("m["+(j*(n+1)+i)+"]"),lvalue=accessors.point(iterators.concat([i])),rvalue="("+terms.join(" + ")+") / w",code.push(lvalue+" = "+rvalue+";")}for(i=nurbs.splineDimension-1;0<=i;i--)code.push("}");code.push("return this;"),code.push("}");var transform=new Function([code.join("\n"),"; return ",functionName].join(""))();return debug&&console.log(code.join("\n")),(transformerCache[cacheKey]=transform).bind(nurbs)}},{"./utils/accessor-preamble":7,"./utils/size-getter":15,"./utils/variable":16}],7:[function(require,module,exports){var inferType=require("./infer-type");module.exports=function(nurbs,variableName,propertyName,data){var i,code=[];switch(inferType(data)){case inferType.NDARRAY:for(code.push("  var "+variableName+" = "+propertyName+".data;"),code.push("  var "+variableName+"Offset = "+propertyName+".offset;"),i=0;i<data.dimension;i++)code.push("  var "+variableName+"Stride"+i+" = "+propertyName+".stride["+i+"];");break;case inferType.ARRAY_OF_ARRAYS:code.push("  var "+variableName+" = "+propertyName+";")}return code.join("\n")}},{"./infer-type":10}],8:[function(require,module,exports){"use strict";var isArrayLike=require("./is-array-like");module.exports=function(nurbs,debug,checkBounds,pointType,weightType,knotType){var d,str,degreeParts=[],hasAnyKnots=!1;for(d=0;d<nurbs.splineDimension;d++){var hasKnots=isArrayLike(nurbs.knots)&&isArrayLike(nurbs.knots[d]);hasKnots&&(hasAnyKnots=!0),degreeParts.push("Deg"+nurbs.degree[d]+(hasKnots?"":"Uniform")+((str=nurbs.boundary[d])[0].toUpperCase()+str.slice(1)))}var parts=[[hasAnyKnots?"NU":"",nurbs.weights?"RBS":"BS"].join("")+nurbs.dimension+"D",degreeParts.join("_")];return pointType&&parts.push(pointType+"Pts"),weightType&&parts.push(weightType+"Wts"),knotType&&parts.push(knotType+"Kts"),debug&&parts.push("debug"),checkBounds&&parts.push("chk"),parts.join("_")}},{"./is-array-like":11}],9:[function(require,module,exports){"use strict";var inferType=require("./infer-type"),createVariable=require("./variable");function wrapAccessor(callback){return function(i,period){void 0===i||Array.isArray(i)||(i=[i]);for(var dimAccessors=[],j=0;j<i.length;j++)dimAccessors.push(createVariable.sum(i[j]));if(period)for(i=0;i<dimAccessors.length;i++)void 0!==period[i]&&(dimAccessors[i]="("+dimAccessors[i]+" + "+period[i]+") % "+period[i]);return callback(dimAccessors)}}function createAccessor(name,data){var i;if(data)switch(inferType(data)){case inferType.ARRAY_OF_ARRAYS:return wrapAccessor(function(accessors){return name+"["+accessors.join("][")+"]"});case inferType.GENERIC_NDARRAY:return wrapAccessor(function(accessors){return name+".get("+accessors.join(",")+")"});case inferType.NDARRAY:return wrapAccessor(function(accessors){var code=[name+"Offset"];for(i=0;i<accessors.length;i++)code.push(name+"Stride"+i+" * ("+accessors[i]+")");return name+"["+code.join(" + ")+"]"});case inferType.PACKED:default:return}}module.exports=function(nurbs){var accessor,accessors={};return(accessor=createAccessor("x",nurbs.points))&&(accessors.point=accessor),(accessor=createAccessor("w",nurbs.weights))&&(accessors.weight=accessor),(accessor=createAccessor("k",nurbs.knots))&&(accessors.knot=accessor),accessors}},{"./infer-type":10,"./variable":16}],10:[function(require,module,exports){"use strict";var isNdarray=require("./is-ndarray"),isNdarrayLike=require("./is-ndarray-like"),isArrayLike=require("./is-array-like");function inferType(x){if(x){if(isNdarray(x)||isNdarrayLike(x))return"generic"===x.dtype?inferType.GENERIC_NDARRAY:inferType.NDARRAY;if(isArrayLike(x))return inferType.ARRAY_OF_ARRAYS;throw new Error("Unhandled data type. Got type: "+typeof x)}}inferType.ARRAY_OF_ARRAYS="Arr",inferType.NDARRAY="Nd",inferType.GENERIC_NDARRAY="GenNd",inferType.PACKED="PackArr",module.exports=inferType},{"./is-array-like":11,"./is-ndarray":13,"./is-ndarray-like":12}],11:[function(require,module,exports){"use strict";module.exports=function(data){return Array.isArray(data)||ArrayBuffer.isView(data)}},{}],12:[function(require,module,exports){module.exports=function(arr){return!!arr&&(void 0!==arr.data&&Array.isArray(arr.shape)&&void 0!==arr.offset&&void 0!==arr.stride)}},{}],13:[function(require,module,exports){"use strict";module.exports=function(arr){return!!arr&&(!!arr.dtype&&new RegExp("function View[0-9]+d(:?"+arr.dtype+")+").test(String(arr.constructor)))}},{}],14:[function(require,module,exports){"use strict";module.exports=function(n,callback){for(var m=1,k=0,i=[];k<n.length;k++)m*=Array.isArray(n[k])?n[k][1]-n[k][0]:n[k],i[k]=Array.isArray(n[k])?n[k][0]:0;for(var ptr=0;ptr<m;ptr++)for(callback(i.slice()),k=n.length-1;0<=k;k--){if(i[k]!==(Array.isArray(n[k])?n[k][1]:n[k])-1){i[k]++;break}i[k]=Array.isArray(n[k])?n[k][0]:0}}},{}],15:[function(require,module,exports){"use strict";var isNdarrayLike=require("./is-ndarray-like");module.exports=function(data,dataVariableName,dimension){if(data){if(isNdarrayLike(data))return dataVariableName+".shape["+dimension+"]";for(var str=dataVariableName,i=0;i<dimension;i++)str+="[0]";return str+".length"}return"this.size["+dimension+"]"}},{"./is-ndarray-like":12}],16:[function(require,module,exports){"use strict";var createVariable=function createVariable(name,nurbs){return function(i,period){void 0===i||Array.isArray(i)||(i=[i]);for(var dimAccessors=[],j=0;j<i.length;j++)dimAccessors.push(createVariable.sum(i[j]));if(period)for(i=0;i<dimAccessors.length;i++)void 0!==period[i]&&(dimAccessors[i]="("+dimAccessors[i]+" + "+period[i]+") % "+period[i]);return name+dimAccessors.join("_")}};createVariable.sum=function(parts){return 0===(parts=(parts=Array.isArray(parts)?parts:[parts]).filter(function(part){return void 0!==part&&0!==part})).length&&parts.push(0),parts.join(" + ")},module.exports=createVariable},{}]},{},[1])(1)});
